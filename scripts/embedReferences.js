#!/usr/bin/env node

/**
 * Generate SigLIP embeddings for curated reference photos.
 * Usage:
 *   EXPO_PUBLIC_HF_TOKEN=your_token_here node scripts/embedReferences.js
 */

const fs = require('fs/promises');
const path = require('path');
const process = require('process');

const HF_MODEL_ID = 'google/siglip-so400m-patch14-384';
const HF_ENDPOINT = `https://api-inference.huggingface.co/embeddings/${HF_MODEL_ID}`;
const TOKEN = process.env.EXPO_PUBLIC_HF_TOKEN || process.env.HF_TOKEN;

if (!TOKEN) {
  console.error('Missing Hugging Face token. Set EXPO_PUBLIC_HF_TOKEN or HF_TOKEN.');
  process.exit(1);
}

const ROOT = path.resolve(__dirname, '..');
const ASSETS_DIR = path.resolve(ROOT, 'assets', 'reference-machines');
const OUTPUT_PATH = path.resolve(ROOT, 'src', 'data', 'referenceMachineEmbeddings.ts');

const IMAGE_EXTS = new Set(['.jpg', '.jpeg', '.png', '.webp']);
const MIME_BY_EXT = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.webp': 'image/webp',
};

// Keep in sync with src/data/labelSynonyms.ts
const LABEL_TO_MACHINE = {
  lat_pulldown_station: 'lat_pulldown',
  seated_row_machine: 'seated_row',
  leg_press_sled: 'leg_press',
  chest_press_machine: 'chest_press',
  shoulder_press_machine: 'shoulder_press',
  treadmill_cardio: 'treadmill',
};

async function main() {
  const references = [];
  let labelDirs;

  try {
    labelDirs = await fs.readdir(ASSETS_DIR, { withFileTypes: true });
  } catch (error) {
    console.error(`Failed to read ${ASSETS_DIR}. Did you add reference photos?`, error);
    process.exit(1);
  }

  for (const entry of labelDirs) {
    if (!entry.isDirectory()) {
      continue;
    }

    const labelId = entry.name;
    const labelPath = path.join(ASSETS_DIR, labelId);
    const files = await fs.readdir(labelPath);

    for (const file of files) {
      const ext = path.extname(file).toLowerCase();
      if (!IMAGE_EXTS.has(ext)) {
        continue;
      }

      const filePath = path.join(labelPath, file);
      const embedding = await embedImage(filePath, MIME_BY_EXT[ext]);

      references.push({
        id: `${labelId}__${path.parse(file).name}`,
        labelId,
        machineId: LABEL_TO_MACHINE[labelId],
        embedding,
      });

      console.log(`Embedded ${path.relative(ROOT, filePath)}`);
      await sleep(250);
    }
  }

  references.sort((a, b) => a.id.localeCompare(b.id));

  const fileContent = [
    '// Auto-generated by scripts/embedReferences.js',
    '// Do not edit manually.',
    '',
    'export interface ReferenceMachineEmbedding {',
    '  id: string;',
    '  labelId: string;',
    '  machineId?: string;',
    '  embedding: number[];',
    '  notes?: string;',
    '}',
    '',
    `export const REFERENCE_MACHINE_EMBEDDINGS: ReferenceMachineEmbedding[] = ${JSON.stringify(
      references,
      null,
      2
    )};`,
    '',
  ].join('\n');

  await fs.writeFile(OUTPUT_PATH, fileContent);
  console.log(
    `Wrote ${references.length} embeddings to ${path.relative(ROOT, OUTPUT_PATH)}`
  );
}

async function embedImage(filePath, mime) {
  const buffer = await fs.readFile(filePath);
  const base64 = buffer.toString('base64');
  const response = await fetch(HF_ENDPOINT, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      inputs: {
        image: `data:${mime};base64,${base64}`,
      },
    }),
  });

  if (!response.ok) {
    const errorPayload = await response.text();
    throw new Error(`Failed to embed ${filePath}: ${errorPayload}`);
  }

  const payload = await response.json();
  if (Array.isArray(payload?.data)) {
    return payload.data;
  }
  if (Array.isArray(payload?.embedding)) {
    return payload.embedding;
  }
  if (Array.isArray(payload)) {
    return payload;
  }

  throw new Error(`Unexpected response for ${filePath}`);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

main().catch(error => {
  console.error(error);
  process.exit(1);
});
